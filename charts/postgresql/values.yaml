## @section Global parameters
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass
##

## @param global.imageRegistry Global Docker image registry
## @param global.imagePullSecrets Global Docker registry secret names as an array
## @param global.storageClass Global StorageClass for Persistent Volume(s)
##
global:
  imageRegistry: ""
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []
  storageClass: ""

## @section Common parameters
##
## @param nameOverride String to partially override common.names.name
##
nameOverride: ""
## @param fullnameOverride String to fully override common.names.fullname
##
fullnameOverride: ""
## @param commonLabels Labels to add to all deployed objects
##
commonLabels: {}
## @param commonAnnotations Annotations to add to all deployed objects
##
commonAnnotations: {}
## Diagnostic mode
## @param diagnosticMode.enabled Enable diagnostic mode (all probes will be disabled and the command will be overridden)
## @param diagnosticMode.command Command to override all containers in the chart release
## @param diagnosticMode.args Args to override all containers in the chart release
##
diagnosticMode:
  enabled: false
  command:
    - sleep
  args:
    - infinity

## @section postgresql Parameters
##

## %%MAIN_CONTAINER/POD_DESCRIPTION%%
##
postgresql:
  ## @param postgresql.pod Pod configuration
  ## @param postgresql.pod.enabled Run postgresql as a Pod rather than a Deployment
  ## @param postgresql.pod.restartPolicy postgresql pod container restart policy.
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
  ##
  pod:
    enabled: true
    restartPolicy: Never
  ## @param postgresql.hostNetwork Specify if host network should be enabled for postgresql pod
  ##
  hostNetwork: true
  ## @param postgresql.dnsConfig  Allows users more control on the DNS settings for a Pod.
  ## Ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  ## E.g.
  ## dnsConfig:
  ##   nameservers:
  ##     - 192.0.2.1 # this is an example
  ##   searches:
  ##     - ns1.svc.cluster-domain.example
  ##     - my.dns.search.suffix
  ##   options:
  ##     - name: ndots
  ##       value: "2"
  ##     - name: edns0
  ##
  dnsConfig: {}
  ## @param postgresql.dnsPolicy Deployment pod DNS policy
  ## ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
  ## E.g.
  ## dnsPolicy: ClusterFirstWithHostNet
  ##
  dnsPolicy: ""
  ## sclorg postgresql-16-c10s image
  ## ref: https://quay.io/repository/sclorg/postgresql-16-c10s?tab=tags
  ## @param postgresql.image.registry postgresql image registry
  ## @param postgresql.image.repository postgresql image repository
  ## @param postgresql.image.tag postgresql image tag (immutable tags are recommended)
  ## @param postgresql.image.digest postgresql image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag image tag (immutable tags are recommended)
  ## @param postgresql.image.pullPolicy postgresql image pull policy
  ## @param postgresql.image.pullSecrets postgresql image pull secrets
  ##
  image:
    registry: quay.io
    repository: sclorg/postgresql-16-c10s
    tag: "20250912"
    digest: ""
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  ## @param postgresql.replicaCount Number of postgresql replicas to deploy if workloadKind set to deployment
  ##
  replicaCount: 1
  ## @param postgresql.containerPorts postgresql container port to expose to host
  ## e.g.
  ## containerPorts:
  ##   - name: postgresql
  ##     containerPort: 5432
  ##     hostPort: 5432
  ##     hostIP: 127.0.0.1
  ##     protocol: TCP
  ##
  containerPorts: []
  ## Configure extra options for postgresql containers' liveness and readiness probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
  ## @param postgresql.livenessProbe.enabled Enable livenessProbe on postgresql containers
  ## @param postgresql.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
  ## @param postgresql.livenessProbe.periodSeconds Period seconds for livenessProbe
  ## @param postgresql.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
  ## @param postgresql.livenessProbe.failureThreshold Failure threshold for livenessProbe
  ## @param postgresql.livenessProbe.successThreshold Success threshold for livenessProbe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 3
    periodSeconds: 600
    timeoutSeconds: 10
    failureThreshold: 5
    successThreshold: 1
    exec:
      command:
        - pg_isready
  ## @param postgresql.readinessProbe.enabled Enable readinessProbe on postgresql containers
  ## @param postgresql.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
  ## @param postgresql.readinessProbe.periodSeconds Period seconds for readinessProbe
  ## @param postgresql.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
  ## @param postgresql.readinessProbe.failureThreshold Failure threshold for readinessProbe
  ## @param postgresql.readinessProbe.successThreshold Success threshold for readinessProbe
  ## note: podman not support readinessProbe currently
  ##
  readinessProbe:
    enabled: false
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1
  ## @param postgresql.startupProbe.enabled Enable startupProbe on postgresql containers
  ## @param postgresql.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
  ## @param postgresql.startupProbe.periodSeconds Period seconds for startupProbe
  ## @param postgresql.startupProbe.timeoutSeconds Timeout seconds for startupProbe
  ## @param postgresql.startupProbe.failureThreshold Failure threshold for startupProbe
  ## @param postgresql.startupProbe.successThreshold Success threshold for startupProbe
  ##
  startupProbe:
    enabled: false
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 15
    successThreshold: 1
  ## @param postgresql.customLivenessProbe Custom livenessProbe that overrides the default one
  ##
  customLivenessProbe: {}
  ## @param postgresql.customReadinessProbe Custom readinessProbe that overrides the default one
  ##
  customReadinessProbe: {}
  ## @param postgresql.customStartupProbe Custom startupProbe that overrides the default one
  ##
  customStartupProbe: {}
  ## postgresql resource requests and limits
  ## ref: http://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  ## @param postgresql.resourcesPreset Set postgresql container resources according to one common preset (allowed values: none, nano, small, medium, large, xlarge, 2xlarge). This is ignored if postgresql.resources is set (postgresql.resources is recommended for production).
  ## More information: https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15
  ##
  resourcesPreset: "nano"
  ## @param postgresql.resources Set postgresql container requests and limits for different resources like CPU or memory (essential for production workloads)
  ## Example:
  ## resources:
  ##   requests:
  ##     cpu: 2
  ##     memory: 512Mi
  ##   limits:
  ##     cpu: 3
  ##     memory: 1024Mi
  ##
  resources: {}
  ## Configure Pods Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param postgresql.podSecurityContext.enabled Enabled postgresql pods' Security Context
  ## @param postgresql.podSecurityContext.fsGroup Set postgresql pod's Security Context fsGroup
  ## note: podman kube play does not support fsGroup yet
  ##
  podSecurityContext:
    enabled: false
    # fsGroup: 1001
  ## Configure Container Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  ## @param postgresql.containerSecurityContext.enabled Enabled postgresql containers' Security Context
  ## @param postgresql.containerSecurityContext.runAsUser Set postgresql containers' Security Context runAsUser
  ## @param postgresql.containerSecurityContext.runAsNonRoot Set postgresql containers' Security Context runAsNonRoot
  ## @param postgresql.containerSecurityContext.readOnlyRootFilesystem Set postgresql containers' Security Context runAsNonRoot
  ##
  containerSecurityContext:
    enabled: true
    runAsUser: 26
    runAsNonRoot: true
    readOnlyRootFilesystem: false

  # %%OTHER_PARAMETERS_RELATED_TO_THIS_CONTAINER/POD%%
  ## @param postgresql.config environment variable config for postgresql
  ## ref: https://github.com/sclorg/postgresql-container/tree/master/16#environment-variables-and-volumes
  ##
  config:
    ## @param postgresql.config.POSTGRESQL_USER User name for PostgreSQL account to be created
    ##
    POSTGRESQL_USER: user
    ## @param postgresql.config.POSTGRESQL_DATABASE Database name
    ##
    POSTGRESQL_DATABASE: database
    ## Alternatively, the following options are related to migration scenario:
    ## @param postgresql.config.POSTGRESQL_MIGRATION_REMOTE_HOST Hostname/IP to migrate from
    ##
    POSTGRESQL_MIGRATION_REMOTE_HOST:
    ## @param postgresql.config.POSTGRESQL_MIGRATION_IGNORE_ERRORS Set to 'yes' to ignore sql import errors, optional, default 'no'
    ##
    POSTGRESQL_MIGRATION_IGNORE_ERRORS: no
    ## The following environment variables influence the PostgreSQL configuration file. They are all optional.
    ## @param postgresql.config.POSTGRESQL_MAX_CONNECTIONS The maximum number of client connections allowed
    ## default: 100
    ##
    POSTGRESQL_MAX_CONNECTIONS:
    ## @param postgresql.config.POSTGRESQL_MAX_PREPARED_TRANSACTIONS Sets the maximum number of transactions that can be in the "prepared" state. If you are using prepared transactions, you will probably want this to be at least as large as max_connections
    ## default: 0
    ##
    POSTGRESQL_MAX_PREPARED_TRANSACTIONS:
    ## @param postgresql.config.POSTGRESQL_SHARED_BUFFERS Sets how much memory is dedicated to PostgreSQL to use for caching data
    ## default: 1/4 of memory limit or 32MB
    ##
    POSTGRESQL_SHARED_BUFFERS:
    ## @param postgresql.config.POSTGRESQL_EFFECTIVE_CACHE_SIZE Set to an estimate of how much memory is available for disk caching by the operating system and within the database itself
    ## default: 1/2 of memory limit or 128MB
    ##
    POSTGRESQL_EFFECTIVE_CACHE_SIZE:
    ## @param postgresql.config.POSTGRESQL_LOG_DESTINATION Where to log errors,
    ## the default is /var/lib/pgsql/data/userdata/log/postgresql-*.log and this file is rotated; it can be changed to /dev/stderr to make debugging easier
    ##
    POSTGRESQL_LOG_DESTINATION: /var/lib/pgsql/data/userdata/log/postgresql-*.log
    ## The following environment variables deal with extensions. They are all optional, and if not set, no extensions will be enabled.
    ## @param postgresql.config.POSTGRESQL_LIBRARIES A comma-separated list of libraries that Postgres will preload using sharedpreloadlibraries.
    ##
    POSTGRESQL_LIBRARIES:
    ## @param postgresql.config.POSTGRESQL_EXTENSIONS A space-separated list of extensions to create when the server start. Once created, the extensions will stay even if the variable is cleared.
    ##
    POSTGRESQL_EXTENSIONS:
  ## @param postgresql.extending directories to config extend feature for the image
  ## ref: https://github.com/sclorg/postgresql-container/blob/master/16/root/usr/share/container-scripts/postgresql/README.md#extending-image
  ##
  extending:
    ## @param postgresql.extending.preStart This directory (postgresql-pre-start/) should contain *.sh files that will be sourced during the early start of the container.
    ## At this point, there is no PostgreSQL daemon running in the background.
    ## ref: https://github.com/sclorg/postgresql-container/blob/master/16/root/usr/share/container-scripts/postgresql/README.md#postgresql-pre-start
    ## e.g.
    ## pre-start:
    ##   enable_ssl.sh: |
    ##     #!/bin/bash
    ##     # Postgresql server will reject key files with liberal permissions
    ##     # This might fail in OpenShift when using a restricted SCC
    ##     # Make sure to run this deployment with an OpenShift service account using  the anyuid SCC
    ##     chmod og-rwx certs/tls.key
    ##
    pre-start: {}
    ## @param postgresql.extending.cfg Configuration files (`*.conf`) contained in this directory ("${APP_DATA}"/src/postgresql-cfg/, ${APP_DATA} default to /opt/app-root ) will be included at the end of the image's postgresql.conf file.
    ## ref: https://github.com/sclorg/postgresql-container/blob/master/16/root/usr/share/container-scripts/postgresql/README.md#postgresql-cfg
    ## ref: https://github.com/sclorg/postgresql-container/blob/1e8796fa71e6f9920c7c12c870567d137ce332b9/16/root/usr/share/container-scripts/postgresql/common.sh#L168
    ## ref: https://github.com/sclorg/postgresql-container/blob/1e8796fa71e6f9920c7c12c870567d137ce332b9/src/Dockerfile#L19
    ## e.g.
    ## cfg:
    ##   ssl.conf: |
    ##     ssl = on
    ##     ssl_cert_file = '/opt/app-root/src/certs/tls.crt' # server certificate
    ##     ssl_key_file =  '/opt/app-root/src/certs/tls.key' # server private key
    ##     #ssl_ca_file                                   # trusted certificate authorities
    ##     #ssl_crl_file                                  # certificates revoked by certificate authorities
    ##
    cfg: {}
    ## @param postgresql.extending.init This directory (postgresql-init/) should contain shell scripts (*.sh) that are sourced when the database is freshly initialized
    ## (after a successful initdb run, which makes the data directory non-empty).
    ## At the time of sourcing these scripts, the local PostgreSQL server is running.
    ## For re-deployment scenarios with a persistent data directory, the scripts are not sourced (no-op).
    ## ref: https://github.com/sclorg/postgresql-container/blob/master/16/root/usr/share/container-scripts/postgresql/README.md#postgresql-init
    ##  e.g.
    ## init:
    ##   createPgStatStatements.sh: |
    ##     #!/bin/bash
    ##     echo "CREATE EXTENSION pg_stat_statements;" | psql
    ##
    init: {}
    ## @param postgresql.extending.start This directory (postgresql-start/) has the same semantics as postgresql-init/,
    ## except that these scripts are always sourced (after postgresql-init/ scripts, if they exist).
    ##
    start: {}
  ## @param postgresql.secret secret will set in the container, setting tls cert and key or whatever secrets for volume mount or env var
  ##
  secret:
    ## @param postgresql.secret.envVars secret content pass to container via environment variable
    ## e.g.
    ## envVars:
    ##   SECRET_KEY1: secret_value1
    ##   SECRET_KEY2: secret_value2
    ##
    envVars:
      ## @param postgresql.secret.envVars.POSTGRESQL_PASSWORD Password for the user account
      ##
      POSTGRESQL_PASSWORD: password
      ## @param postgresql.secret.envVars.POSTGRESQL_ADMIN_PASSWORD Password for the postgres admin account (optional)
      ##
      POSTGRESQL_ADMIN_PASSWORD: password
      ## @param postgresql.secret.envVars.POSTGRESQL_MIGRATION_ADMIN_PASSWORD Password for the remote 'postgres' admin user
      ##
      # POSTGRESQL_MIGRATION_ADMIN_PASSWORD:
    ## @param postgresql.secret.ssl tls cert and key pass to the container via volume and mount
    ## secret setting of cert and key or whatever ssl content will set in the container
    ##
    ssl:
      ## @param postgresql.secret.ssl.mountPath secret mount path setting of whatever ssl content will set in the container
      ## ref: https://github.com/containers/podman/issues/20956
      ##
      mountPath: /opt/app-root/src/certs:U
      ## @param postgresql.secret.ssl.contents secret content of cert and key or whatever tls content will set in the container
      ## You can set the content key as whatever file name you like
      ## But the tls set in configFiles above must match with the settings here
      ## key and certificate should start with -----BEGIN CERTIFICATE----- or -----BEGIN RSA PRIVATE KEY-----
      ## e.g.
      ## contents:
      ##  tls.crt: ""
      ##  tls.key: ""
      ##
      contents: {}
    ## @param postgresql.secret.others other secret pass to the the container, setting for whatever secrets except tls
    ## e.g.
    ## others:
    ##   mountPath: /secret
    ##   contents:
    ##     secret.file: secret content
    ##
    others: {}

  ## @param postgresql.existingConfigmap The name of an existing ConfigMap with your custom configuration for postgresql
  ##
  existingConfigmap:
  ## @param postgresql.command Override default container command (useful when using custom images)
  ##
  command: []
  ## @param postgresql.args Override default container args (useful when using custom images)
  ##
  args: []
  ## @param postgresql.automountServiceAccountToken Mount Service Account token in postgresql pods
  ##
  automountServiceAccountToken: false
  ## @param postgresql.hostAliases postgresql pods host aliases
  ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
  ##
  hostAliases: []
  ## @param postgresql.deploymentAnnotations Annotations for postgresql deployment
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  deploymentAnnotations: {}
  ## @param postgresql.podLabels Extra labels for postgresql pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## @param postgresql.podAnnotations Annotations for postgresql pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations:
    io.podman.annotations.userns: keep-id:uid=26,gid=26
  ## @param postgresql.podAffinityPreset Pod affinity preset. Ignored if `postgresql.affinity` is set. Allowed values: `soft` or `hard`
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ##
  podAffinityPreset: ""
  ## @param postgresql.podAntiAffinityPreset Pod anti-affinity preset. Ignored if `postgresql.affinity` is set. Allowed values: `soft` or `hard`
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ##
  podAntiAffinityPreset: soft
  ## Node postgresql.affinity preset
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
  ##
  nodeAffinityPreset:
    ## @param postgresql.nodeAffinityPreset.type Node affinity preset type. Ignored if `postgresql.affinity` is set. Allowed values: `soft` or `hard`
    ##
    type: ""
    ## @param postgresql.nodeAffinityPreset.key Node label key to match. Ignored if `postgresql.affinity` is set
    ##
    key: ""
    ## @param postgresql.nodeAffinityPreset.values Node label values to match. Ignored if `postgresql.affinity` is set
    ## E.g.
    ## values:
    ##   - e2e-az1
    ##   - e2e-az2
    ##
    values: []
  ## @param postgresql.affinity Affinity for postgresql pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## NOTE: `postgresql.podAffinityPreset`, `postgresql.podAntiAffinityPreset`, and `postgresql.nodeAffinityPreset` will be ignored when it's set
  ##
  affinity: {}
  ## @param postgresql.nodeSelector Node labels for postgresql pods assignment
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  ##
  nodeSelector: {}
  ## @param postgresql.tolerations Tolerations for postgresql pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## ONLY FOR DEPLOYMENTS:
  ## @param postgresql.updateStrategy.type postgresql deployment strategy type
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  ## ONLY FOR STATEFULSETS:
  ## @param postgresql.updateStrategy.type postgresql statefulset strategy type
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    ## ONLY FOR DEPLOYMENTS:
    ## Can be set to RollingUpdate or Recreate
    ## ONLY FOR STATEFULSETS:
    ## Can be set to RollingUpdate or OnDelete
    ##
    type: RollingUpdate
  ## @param postgresql.priorityClassName postgresql pods' priorityClassName
  ##
  priorityClassName: ""
  ## @param postgresql.topologySpreadConstraints Topology Spread Constraints for postgresql pod assignment spread across your cluster among failure-domains
  ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/#spread-constraints-for-pods
  ##
  topologySpreadConstraints: []
  ## @param postgresql.schedulerName Name of the k8s scheduler (other than default) for postgresql pods
  ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
  ##
  schedulerName: ""
  ## @param postgresql.terminationGracePeriodSeconds Seconds postgresql pods need to terminate gracefully
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
  ##
  terminationGracePeriodSeconds: ""
  ## @param postgresql.lifecycleHooks for postgresql containers to automate configuration before or after startup
  ##
  lifecycleHooks: {}
  ## @param postgresql.extraEnvVars Array with extra environment variables to add to postgresql containers
  ## e.g:
  ## extraEnvVars:
  ##   - name: FOO
  ##     value: "bar"
  ##
  extraEnvVars: []
  ## @param postgresql.extraEnvVarsCM Name of existing ConfigMap containing extra env vars for postgresql containers
  ##
  extraEnvVarsCM: ""
  ## @param postgresql.extraEnvVarsSecret Name of existing Secret containing extra env vars for postgresql containers
  ##
  extraEnvVarsSecret: ""
  ## @param postgresql.extraVolumes Optionally specify extra list of additional volumes for the postgresql pods
  ##
  extraVolumes: []
  ## @param postgresql.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the postgresql containers
  ##
  extraVolumeMounts: []
  ## @param postgresql.sidecars Add additional sidecar containers to the postgresql pods
  ## e.g:
  ## sidecars:
  ##   - name: your-image-name
  ##     image: your-image
  ##     imagePullPolicy: Always
  ##     ports:
  ##       - name: portname
  ##         containerPort: 1234
  ##
  sidecars: []
  ## @param postgresql.initContainers Add additional init containers to the postgresql pods
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  ## e.g:
  ## initContainers:
  ##  - name: your-image-name
  ##    image: your-image
  ##    imagePullPolicy: Always
  ##    command: ['sh', '-c', 'echo "hello world"']
  ##
  initContainers: []

## @section Persistence Parameters
##

## Enable persistence using Persistent Volume Claims
## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
##
persistence:
  ## @param persistence.enabled Enable persistence using Persistent Volume Claims
  ##
  enabled: true
  ## @param persistence.mountPath Path to mount the volume at.
  ##
  mountPath: /var/lib/pgsql/data
  ## @param persistence.subPath The subdirectory of the volume to mount to, useful in dev environments and one PV for multiple services
  ##
  subPath: ""
  ## @param persistence.storageClass Storage class of backing PVC
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  storageClass: ""
  ## @param persistence.annotations Persistent Volume Claim annotations
  ##
  annotations: {}
  ## @param persistence.accessModes Persistent Volume Access Modes
  ##
  accessModes:
    - ReadWriteOnce
  ## @param persistence.size Size of data volume
  ##
  size: 8Gi
  ## @param persistence.dataSource Custom PVC data source
  ##
  dataSource: {}
  ## @param persistence.existingClaim The name of an existing PVC to use for persistence
  ##
  existingClaim: ""
  ## @param persistence.selector Selector to match an existing Persistent Volume for postgresql data PVC
  ## If set, the PVC can't have a PV dynamically provisioned for it
  ## E.g.
  ## selector:
  ##   matchLabels:
  ##     app: my-app
  ##
  selector: {}
## @section Init Container Parameters
##

## @section Default init containers Parameters

defaultInitContainers:
  ## 'volume-permissions' init container
  ## Changes the owner and group of the persistent volume mount(s) point(s) to runAsUser:fsGroup values
  ##   based on the *podSecurityContext/*containerSecurityContext parameters
  ##
  volumePermissions:
    ## @param defaultInitContainers.volumePermissions.enabled Enable init container that adapts the owner/group of the PV mount(s) point(s)
    ##
    enabled: false
    ## OS Shell + Utility image
    ## ref: https://hub.docker.com/r/bitnami/os-shell
    ## @param defaultInitContainers.volumePermissions.image.registry [default: REGISTRY_NAME] "volume-permissions" init-containers' image registry
    ## @param defaultInitContainers.volumePermissions.image.repository [default: REPOSITORY_NAME/os-shell] "volume-permissions" init-containers' image repository
    ## @skip defaultInitContainers.volumePermissions.image.tag "volume-permissions" init-containers' image tag (immutable tags are recommended)
    ## @param defaultInitContainers.volumePermissions.image.digest "volume-permissions" init-containers' image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
    ## @param defaultInitContainers.volumePermissions.image.pullPolicy "volume-permissions" init-containers' image pull policy
    ## @param defaultInitContainers.volumePermissions.image.pullSecrets "volume-permissions" init-containers' image pull secrets
    ##
    image:
      registry: docker.io
      repository: bitnami/os-shell
      tag: 12-debian-12-r46
      digest: ""
      pullPolicy: IfNotPresent
      ## Optionally specify an array of imagePullSecrets.
      ## Secrets must be manually created in the namespace.
      ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      ## Example:
      ## pullSecrets:
      ##   - myRegistryKeySecretName
      ##
      pullSecrets: []
    ## Configure "volume-permissions" init-container Security Context
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.enabled Enabled "volume-permissions" init-containers' Security Context
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.seLinuxOptions [object,nullable] Set SELinux options in "volume-permissions" init-containers
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.runAsUser Set runAsUser in "volume-permissions" init-containers' Security Context
    ## NOTE: when runAsUser is set to special value "auto", init container will try to chown the
    ##   data folder to auto-determined user&group, using commands: `id -u`:`id -G | cut -d" " -f2`
    ##   "auto" is especially useful for OpenShift which has scc with dynamic user ids (and 0 is not allowed)
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.privileged Set privileged in "volume-permissions" init-containers' Security Context
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.allowPrivilegeEscalation Set allowPrivilegeEscalation in "volume-permissions" init-containers' Security Context
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.capabilities.add List of capabilities to be added in "volume-permissions" init-containers
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.capabilities.drop List of capabilities to be dropped in "volume-permissions" init-containers
    ## @param defaultInitContainers.volumePermissions.containerSecurityContext.seccompProfile.type Set seccomp profile in "volume-permissions" init-containers
    ##
    containerSecurityContext:
      enabled: true
      seLinuxOptions: {}
      runAsUser: 0
      privileged: false
      allowPrivilegeEscalation: false
      capabilities:
        add: []
        drop: ["ALL"]
      seccompProfile:
        type: "RuntimeDefault"
    ## "volume-permissions" init container resource requests and limits
    ## ref: http://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    ## @param defaultInitContainers.volumePermissions.resourcesPreset Set "volume-permissions" init container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if defaultInitContainers.volumePermissions.resources is set (defaultInitContainers.volumePermissions.resources is recommended for production).
    ## More information: https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15
    ##
    resourcesPreset: "nano"
    ## @param defaultInitContainers.volumePermissions.resources Set "volume-permissions" init container requests and limits for different resources like CPU or memory (essential for production workloads)
    ## E.g:
    ## resources:
    ##   requests:
    ##     cpu: 2
    ##     memory: 512Mi
    ##   limits:
    ##     cpu: 3
    ##     memory: 1024Mi
    ##
    resources: {}

## @section Other Parameters
##

## ServiceAccount configuration
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
##
serviceAccount:
  ## @param serviceAccount.name The name of the ServiceAccount to use.
  ## If not set and create is true, a name is generated using the common.names.fullname template
  ##
  name: ""

## %%SUBCHART_CONTAINER/POD_DESCRIPTION%%
##
# %%SUBCHART_NAME%%:
SUBCHART_NAME:
  enabled: false
  # %%OTHER_PARAMETERS_RELATED_TO_THIS_SUBCHART%%
